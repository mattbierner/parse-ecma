/**
 * @fileOverview ECMAScript 5.1 statement parsers.
 */
package (
    blockStatement
    variableStatement
    emptyStatement
    expressionStatement
    ifStatement
    forStatement
    forInStatement
    whileStatement
    doWhileStatement
    iterationStatement
    continueStatement
    breakStatement
    returnStatement
    withStatement
    labeledStatement
    switchStatement
    throwStatement
    tryStatement
    debuggerStatement

// Statement
    statement)
with
    import 'bennu::parse' parse#{
        eager
        late
        look
        next
        not},
    import 'bennu::lang' parse_lang#{
        between
        then},
    
    import 'ecma-ast::clause' ast_clause,
    import 'ecma-ast::declaration' ast_declaration,
    import 'ecma-ast::statement' ast_statement,
    import 'ecma-ast::node' {getData},

    import './token_parser' token#{
        keyword
        punctuator},
    import './common' {node nodea},
    import './expression_parser' expression,
    import './value_parser' value
in {

    /* Forward declarations
 ******************************************************************************/
statement = late \-> { return statement; };

/* Helpers
 ******************************************************************************/
// logicalSemiColon
////////////////////////////////////////
/**
 * Checks if a line terminator existed in the original stream.
 */
var lineTerminator = look parse.token(\node -> getData(node, 'lineTerminator'));

/**
 * Consumes 'p' as long as a line terminator did not exist before 'p'.
 */
var noLineTerminator = next @ (not lineTerminator);

/**
 * Matches a logical semicolon in the grammar.
 * 
 * Based on:
 *    'OMeta: an Object-Oriented Language for Pattern Matching',
 *    Alessandro, Warth, Ian Piumarta 2007
 */
var logicalSemiColon = parse.expected('logical semicolon',
    parse.choice(
        punctuator ';',
        parse.look(punctuator '}'),
        lineTerminator,
        parse.eof));

/* Statement labels
 ******************************************************************************/
var statementList = eager(parse.many(statement));

// Block
////////////////////////////////////////
/**
 * Parser for a block statement
 */
blockStatement = parse.label('Block Statement',
    node(
        between(punctuator '{', punctuator '}', 
            statementList),
        ast_statement.BlockStatement.create));

// Variable Statement
////////////////////////////////////////
var initialiser = next(
    punctuator '=',
    parse.expected("initialiser expression", expression.assignmentExpression));

var initialiserNoIn = next(
    punctuator '=',
    parse.expected("initialiser expression", expression.assignmentExpressionNoIn));

/**
 * Parser for a single variable declaration.
 */
var variableDeclaration = nodea(
    parse.enumeration(
        value.identifier,
        parse.optional(initialiser)),
    ast_declaration.VariableDeclarator.create);

/**
 * Parser for a single variable declaration without the in operator.
 */
var variableDeclarationNoIn = nodea(
    parse.enumeration(
        value.identifier,
        parse.optional(initialiserNoIn)),
    ast_declaration.VariableDeclarator.create);

var variableDeclarationList = eager(parse_lang.sepBy1(punctuator ',',
    parse.expected('variable declaration', variableDeclaration)));

var variableDeclarationListNoIn = eager(parse_lang.sepBy1(punctuator ',',
    parse.expected('variable declaration', variableDeclarationNoIn)));

/**
 * Parser for a variable statement which declares one or more variables with
 * optional initializer values.
 */
variableStatement = parse.label('Variable Statement', 
    node(
        between(keyword 'var', logicalSemiColon,
            parse.expected("variable declaration list", variableDeclarationList)),
        ast_declaration.VariableDeclaration.create));

// Empty Statement
////////////////////////////////////////
/**
 * Parser for an empty statement.
 */
emptyStatement = parse.label('Empty Statement',
    node(
        punctuator ';',
        ast_statement.EmptyStatement.create));

// Expression
////////////////////////////////////////
/**
 * Parser for an expression statement.
 *
 * @TODO: Add lookahead not 'function' check?
 */
expressionStatement = parse.label('Expression Statement',
    node(
        then(
            expression.expression,
            logicalSemiColon),
        ast_statement.ExpressionStatement.create));

// If
////////////////////////////////////////
/**
 * Parser for an if statement with optional alternate.
 */
ifStatement = parse.label('If Statement',
    nodea(
        next(
            keyword 'if',
            parse.enumeration(
                between(punctuator '(', punctuator ')',
                    parse.expected("if test", expression.expression)),
                parse.expected("if consequent", statement),
                parse.optional(next(keyword 'else',
                    parse.expected("if alternate", statement))))),
        ast_statement.IfStatement.create));

// Iteration
////////////////////////////////////////
/**
 * Parser for while statement.
 */
whileStatement = parse.label('While Statement',
    nodea(
        next(
            keyword 'while',
            parse.enumeration(
                between(punctuator '(', punctuator ')',
                    parse.expected('while test', expression.expression)),
                parse.expected('while body', statement))),
        ast_statement.WhileStatement.create));

/**
 * Parser for a do while statement.
 */
doWhileStatement = parse.label('Do While Statement',
    nodea(
        next(
            keyword 'do',
            parse.enumeration(
                parse.expected('do-while body', statement),
                next(
                    keyword 'while',
                    between(punctuator '(', punctuator ')',
                        parse.expected('do-while test', expression.expression))),
                punctuator ';')),
        ast_statement.DoWhileStatement.create));

var forInit = parse.either(
    node(
        next(
            keyword 'var',
            parse.expected("variable declaration list", parse.memo(variableDeclarationListNoIn))),
        ast_declaration.VariableDeclaration.create),
    expression.expressionNoIn);

/**
 * Parser for a for statement with optional init, test, and update expressions.
 */
forStatement = parse.label('For Statement',
    nodea(
        next(
            keyword 'for',
            next(
                punctuator '(',
                parse.enumeration(
                    then(
                        parse.optional(forInit),
                        punctuator ';'),
                    then(
                        parse.optional(expression.expressionNoIn),
                        punctuator ';'),
                    then(
                        parse.optional(expression.expressionNoIn),
                        punctuator ')'),
                    statement))),
        ast_statement.ForStatement.create));

var forInLeft = parse.either(
    node(
        next(
            keyword 'var',
            parse.expected("variable declaration", parse.memo(variableDeclarationNoIn))),
        \loc, x ->
            ast_declaration.VariableDeclaration.create(loc, [x])),
    expression.leftHandSideExpression);

/**
 * Parser for a for in statement.
 */
forInStatement = parse.label('For In Statement',
    nodea(
        next(
            keyword 'for',
            next(
                punctuator '(',
                parse.enumeration(
                    then(
                        forInLeft,
                        keyword 'in'),
                    then(
                        expression.expressionNoIn,
                        punctuator ')'),
                    statement))),
        ast_statement.ForInStatement.create));

/**
 * Parser for any iteration statement.
 */
iterationStatement = parse.label('Iteration Statement',
    parse.choice(
        doWhileStatement,
        whileStatement,
        parse.attempt(forInStatement),
        forStatement));

// Continue
////////////////////////////////////////
/**
 * Parser for a continue statement with optional label.
 */
continueStatement = parse.label('Continue Statement',
    node(
        between(keyword 'continue', logicalSemiColon,
            parse.optional(noLineTerminator(value.identifier))),
        ast_statement.ContinueStatement.create));

// Break
////////////////////////////////////////
/**
 * Parser for a break statement with optional label.
 */
breakStatement = parse.label('Break Statement',
    node(
        between(keyword 'break', logicalSemiColon,
            parse.optional(noLineTerminator(value.identifier))),
        ast_statement.BreakStatement.create));

// Return
////////////////////////////////////////
/**
 * Parser for a return statement.
 */
returnStatement = parse.label('Return Statement',
    node(
        between(keyword 'return', logicalSemiColon,
            parse.optional(noLineTerminator(expression.expression))),
        ast_statement.ReturnStatement.create));

// Throw
////////////////////////////////////////
/**
 * Parser for a throw statement.
 */
throwStatement = parse.label('Throw Statement',
    node(
        between(keyword 'throw', logicalSemiColon,
            parse.expected("throw argument", noLineTerminator(expression.expression))),
        ast_statement.ThrowStatement.create));

// With
////////////////////////////////////////
/**
 * Parser for a with statement.
 */
withStatement = parse.label('With Statement',
    nodea(
        next(
            keyword 'with',
            parse.enumeration(
                between(punctuator '(', punctuator ')',
                    parse.expected("with object", expression.expression)),
                parse.expected("with body", statement))),
        ast_statement.WithStatement.create));

// Labeled
////////////////////////////////////////
/**
 * Parser for a labeled statement.
 */
labeledStatement = parse.label('Labeled Statement',
    nodea(
        parse.enumeration(
            then(
                value.identifier,
                punctuator ':'),
            statement),
        ast_statement.LabeledStatement.create));

// Switch
////////////////////////////////////////
/**
 * Parser for a case clause from a switch statement.
 */
var caseClause = nodea(
    next(
        keyword 'case',
        parse.enumeration(
            then(
                parse.expected("case test", expression.expression),
                punctuator ':'),
            statementList)),
    ast_clause.SwitchCase.create);

/**
 * Parser for the default case of a switch statement.
 */
var defaultClause = node(
    next(
        keyword 'default',
        next(
            punctuator ':',
            statementList)),
    \loc, consequent ->
        ast_clause.SwitchCase.create(loc, null, consequent));

var caseClauses = eager(parse.many(caseClause));

var caseBlock = between(punctuator '{', punctuator '}',
    parse.binds(
        parse.enumeration(
            parse.optional([], caseClauses),
            parse.optional(defaultClause),
            parse.optional([], caseClauses)),
        \first, defaultClause, rest ->
            parse.always(?defaultClause
                :first.concat(defaultClause, rest)
                :first.concat(rest))));

/**
 * Parser for a switch statement with zero or more case clauses and zero or one
 * default case clauses in any order.
 */
switchStatement = parse.label('Switch Statement',
    nodea(
        next(
            keyword 'switch',
            parse.enumeration(
                between(punctuator '(', punctuator ')',
                    expression.expression),
                caseBlock)),
        ast_statement.SwitchStatement.create));

// Try
////////////////////////////////////////
/**
 * Parser for a catch block in a try statement.
 */
var catchBlock = nodea(
    next(
        keyword 'catch',
        parse.enumeration(
            between(punctuator '(', punctuator ')',
                value.identifier),
            parse.expected("block statement", blockStatement))),
    ast_clause.CatchClause.create);

/**
 * Parser for a finally block in try statement.
 */
var finallyBlock = next(
    keyword 'finally',
    parse.expected("block statement", blockStatement));

/**
 * Parser for a try statement with optional catch and finally blocks.
 */
tryStatement = parse.label('Try Statement',
    nodea(
        next(
            keyword 'try',
            parse.enumeration(
                parse.expected("block statement", blockStatement),
                parse.optional(catchBlock),
                parse.optional(finallyBlock))),
        ast_statement.TryStatement.create));

// Debugger
////////////////////////////////////////
/**
 * Parser for a debugger statement.
 */
debuggerStatement = parse.label('Debugger Statement',
    node(
        next(
            keyword 'debugger',
            punctuator ';'),
        ast_statement.DebuggerStatement.create));

// statement
////////////////////////////////////////
/**
 * 
 */
statement = parse.label('Statement',
    parse.expected("statement", parse.choice(
        blockStatement,
        variableStatement,
        emptyStatement,
        ifStatement,
        iterationStatement,
        continueStatement,
        breakStatement,
        returnStatement,
        withStatement,
        switchStatement,
        throwStatement,
        tryStatement,
        debuggerStatement,
        parse.attempt(labeledStatement),
        expressionStatement)));

}