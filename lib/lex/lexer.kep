/**
 * @fileOverview Lexers for ECMAScript 5.1.
 */
package (
    comment
    whitespace
    lineTerminator
    
    token
    
    lexState
    lexStream
    lex)
with
    import 'bennu::parse' parse#{
        always
        attempt
        binds
        bind
        choice
        eof
        getPosition
        modifyParserState
        getState
        enumeration
        extract
        next
        many
        runState
        never},
    import 'bennu::lang' {then},
    import 'nu-stream::stream' {'from': streamFrom},
    
    import 'ecma-ast::token' lexToken,
    import 'ecma-ast::position' {SourceLocation SourcePosition},
    
    import './state' ParserState,
    import './boolean_lexer' {booleanLiteral},
    import './comment_lexer' comment_lexer,
    import './identifier_lexer' {identifier},
    import './line_terminator_lexer' line_terminator_lexer,
    import './null_lexer' {nullLiteral},
    import './number_lexer' {numericLiteral},
    import './punctuator_lexer' {punctuator divPunctuator},
    import './reserved_word_lexer' {reservedWord},
    import './string_lexer' {stringLiteral},
    import './whitespace_lexer' whitespace_lexer,
    import './regular_expression_lexer' {regularExpressionLiteral}
in {

var position = getPosition;//.map (.position);

var makeToken = \type p ->
    bind(p, \x ->
        always [type, x]);

var buildToken = \p ->
    binds(
        enumeration(
            getPosition,
            p,
            getPosition),
        \start [type value] end ->
            always(new type(
                new SourceLocation(start, end, start.file || end.file),
                value)))
    .chain \tok ->
        next(
            modifyParserState \s ->
            s.consume(tok),
            always tok);

var isRegExpCtx := extract((.prevTok)).chain \ prev -> {
    if (!prev) return always();
    switch (prev.type) {
    case 'Keyword':
    case 'Punctuator':
        return always();
    
    }
    return never();
};

/* Lexers
 ******************************************************************************/
// Literal
////////////////////////////////////////
/**
 * Literal in division contexts.
 */
var literal = choice(
    makeToken(
        lexToken.StringToken.create,
        stringLiteral),
    makeToken(
        lexToken.BooleanToken.create,
        booleanLiteral),
    makeToken(
        lexToken.NullToken.create,
        nullLiteral),
    makeToken(
        lexToken.NumberToken.create,
        numericLiteral),
    makeToken(
        lexToken.RegularExpressionToken.create,
        next(
            isRegExpCtx,
            regularExpressionLiteral)));

// Token
////////////////////////////////////////
/**
 * Lexer for a token in division contexts.
 */
var tokenToken = choice(
    attempt makeToken(
        lexToken.IdentifierToken,
        identifier),
    literal,
    makeToken(
        lexToken.KeywordToken,
        reservedWord),
    makeToken(
        lexToken.PunctuatorToken,
        punctuator));

token = buildToken tokenToken;

// Input Element
////////////////////////////////////////
var commentToken := makeToken(
    lexToken.CommentToken,
    comment_lexer.comment);

var whitespaceToken := makeToken(
    lexToken.WhitespaceToken,
    whitespace_lexer.whitespace);

var lineTerminatorToken := makeToken(
    lexToken.LineTerminatorToken,
    line_terminator_lexer.lineTerminator);

comment = buildToken commentToken;
whitespace = buildToken whitespaceToken;
lineTerminator = buildToken lineTerminatorToken;

/**
 * Lexer for a top level element in division contexts.
 */
var inputElement = choice(
    commentToken,
    whitespaceToken,
    lineTerminatorToken,
    tokenToken);

// Lexers
////////////////////////////////////////
/**
 * Lexer for a stream of tokens in leading division grammars.
 * 
 * Lexes as much input as possible, does not check for eof.
 */
var lexer = many buildToken(inputElement);

/* Running
 ******************************************************************************/
// Lex Div 
////////////////////////////////////////
/**
 * Lexes state in division context.
 */
lexState = \state ->
    runState(
        then(
            lexer,
            eof),
        state);

/**
 * Lexes stream in division context.
 */
lexStream = \s file -> 
    lexState(
        new ParserState(
            s,
            new SourcePosition(1, 0, file)));

/**
 * Lexes array-like input in division context.
 */
lex = streamFrom \> lexStream;

}